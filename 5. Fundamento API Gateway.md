# Resumo da Aula sobre API Gateway em Microserviços

## Introdução
A aula aborda o conceito de **API Gateway**, um componente essencial em arquiteturas de microserviços para centralizar a comunicação entre o front-end e os serviços. O exemplo continua com os serviços de **encurtamento de URLs**, **analytics** e **autenticação**, destacando como o API Gateway atua como um proxy, simplificando a interação do front-end e adicionando funcionalidades como autenticação e *rate limiting*. O projeto no GitHub usa o **Kong** como API Gateway, com configurações definidas em um arquivo `kong.yml`. A aula conecta os conceitos anteriores (autenticação, persistência, comunicação) e explora a implementação prática.

## Conceitos Fundamentais
- **API Gateway**:
  - Um serviço que atua como ponto único de entrada para requisições HTTP, centralizando a comunicação entre o front-end e os microserviços.
  - **Função**: Encaminha requisições do front-end para o serviço correto (ex.: `/shortener/*` para o Shortener, `/analytics/*` para o Analytics).
  - **Benefício**: Evita que o front-end gerencie URLs individuais de cada serviço, reduzindo complexidade em arquiteturas com muitos serviços (ex.: 10, 50, 1000).
- **Proxy Reverso**:
  - O API Gateway funciona como um *proxy reverso*, redirecionando requisições com base em rotas configuradas.
  - Exemplo: Requisições para `localhost/shortener/*` são encaminhadas ao serviço Shortener; `/analytics/*` ao Analytics.
- **Funcionalidades Adicionais**:
  - **Rate Limiting**: Limita o número de requisições por usuário (ex.: 60 requisições por minuto por IP ou ID de usuário), retornando HTTP 429 (*Too Many Requests*) se excedido.
  - **Autenticação**: Valida JWTs no API Gateway, evitando validação redundante em cada serviço.
  - **Payload do Token**: Pode extrair dados do JWT (ex.: `user_id`) e encaminhá-los aos serviços, simplificando o processamento.
- **Integração com Autenticação**:
  - O API Gateway consulta o endpoint `/jwks` do serviço de autenticação para obter a chave pública e validar JWTs.
  - Após validação, envia dados do payload (ex.: `X-User-Id`) aos serviços, eliminando a necessidade de revalidação.

## Exemplo Prático
- **Cenário: Comunicação via API Gateway**:
  - **Serviços**:
    - **Shortener**: Gerencia criação de URLs, acessado via `/shortener/*`.
    - **Analytics**: Gerencia métricas de cliques, acessado via `/analytics/*`.
    - **Autenticação**: Fornece endpoint `/jwks` para validação de JWTs.
  - **Fluxo**:
    - O front-end envia requisições HTTP para o API Gateway (ex.: `localhost/shortener/create`).
    - O API Gateway valida o JWT consultando o endpoint `/jwks` do serviço de autenticação.
    - Se válido, extrai o `user_id` do JWT e adiciona ao cabeçalho (ex.: `X-User-Id`) antes de encaminhar ao Shortener.
    - O Shortener processa a requisição sem precisar validar o JWT, confiando no API Gateway.
  - **Rate Limiting**:
    - O API Gateway limita requisições (ex.: 60 por minuto por usuário).
    - Retorna HTTP 429 se o limite for excedido, protegendo os serviços de sobrecarga.
- **Benefício**:
  - O front-end só precisa conhecer a URL do API Gateway (ex.: `localhost`), configurada em um arquivo `.env`.
  - Simplifica a manutenção em arquiteturas com múltiplos serviços.

## Implementação no Código
- **Estrutura do Projeto**:
  - **API Gateway**: Usa **Kong**, configurado via `kong.yml`.
  - **Serviços**:
    - `apps/shortener`: Rota `/api/urls/*` redirecionada pelo Kong.
    - `apps/analytics`: Rota `/api/analytics/*` redirecionada pelo Kong.
    - `apps/auth`: Rota `/auth/*` para autenticação e endpoint `/jwks`.
  - **Docs**: Documentação detalhada sobre o fluxo do API Gateway e autenticação.
- **Configuração do Kong**:
  - Arquivo `kong.yml` define:
    - **Rotas**:
      - `/auth/*`: Redireciona para o serviço de autenticação (ex.: porta específica).
      - `/api/urls/*`: Redireciona para o Shortener.
      - `/api/analytics/*`: Redireciona para o Analytics (ex.: porta 3001).
    - **Plugins**:
      - Plugin JWT: Configurado para Shortener e Analytics, valida JWTs automaticamente.
      - *Consumer*: Define como o JWT é validado (idealmente via `/jwks`, mas no exemplo usa um *secret* direto para simplicidade).
  - **Docker Compose**: Sobe o Kong e os serviços, com o Kong rodando como API Gateway.
- **Autenticação no Kong**:
  - O Kong valida JWTs antes de encaminhar requisições.
  - Extrai o `user_id` do JWT e adiciona ao cabeçalho `X-User-Id` para os serviços.
  - Exemplo: O Analytics recebe `X-User-Id` e usa diretamente, sem revalidação.
- **Problemas no Código**:
  - O instrutor menciona erros no JWT que estão sendo corrigidos.
  - O código no GitHub estará funcional, com a interface do Kong mostrando as configurações de `kong.yml` de forma visual.

## Desafios do API Gateway
1. **Complexidade de Configuração**:
   - Configurar rotas e plugins (ex.: JWT, *rate limiting*) exige planejamento, especialmente com muitos serviços.
   - Solução: Usar arquivos como `kong.yml` para centralizar configurações.
2. **Dependência do API Gateway**:
   - Se o Kong falhar, todas as requisições do front-end são afetadas.
   - Solução: Configurar alta disponibilidade (ex.: múltiplas instâncias do Kong no Kubernetes).
3. **Autenticação Centralizada**:
   - O API Gateway deve consultar o serviço de autenticação, aumentando a latência se o endpoint `/jwks` for lento.
   - Solução: Cache da chave pública com TTL para reduzir chamadas.
4. **Rate Limiting**:
   - Definir limites apropriados (ex.: 60 requisições/minuto) requer testes para evitar bloqueios injustos ou sobrecarga.
5. **Manutenção**:
   - Atualizações nas rotas ou plugins exigem alterações no `kong.yml` e redeploy do Kong.
   - Solução: Automatizar deploys com CI/CD.

## Boas Práticas
- **Centralizar Comunicação**:
  - Usar o API Gateway como único ponto de entrada para o front-end, simplificando a configuração no `.env`.
- **Autenticação no Gateway**:
  - Validar JWTs no API Gateway, usando o endpoint `/jwks` para obter chaves públicas.
  - Encaminhar dados do JWT (ex.: `X-User-Id`) para os serviços, evitando revalidação.
- **Rate Limiting**:
  - Configurar limites por IP ou ID de usuário (ex.: 60 requisições/minuto) para proteger os serviços.
  - Retornar HTTP 429 para informar o usuário sobre excesso de requisições.
- **Configuração Declarativa**:
  - Usar arquivos como `kong.yml` para definir rotas e plugins, facilitando manutenção.
- **Monitoramento**:
  - Monitorar o Kong com **Prometheus** e **Grafana** para rastrear latência, erros (ex.: HTTP 429) e saúde do serviço.
  - Registrar logs de requisições para debugging.
- **Alta Disponibilidade**:
  - Implantar múltiplas instâncias do Kong no Kubernetes para evitar pontos únicos de falha.
- **Documentação**:
  - Incluir detalhes do fluxo do API Gateway na pasta `docs`.
  - Documentar rotas e plugins em `contracts` para clareza.

## Relação com o Kubernetes
- **Conexão com o Módulo Anterior**:
  - O Kong é implantado como um **Deployment** no Kubernetes, com **Services** para expor rotas (ex.: `/shortener`, `/analytics`).
  - **ConfigMaps** armazenam o arquivo `kong.yml`.
  - **Secrets** gerenciam chaves sensíveis (ex.: *secret* do JWT, se usado).
  - **HPA** escala o Kong com base na carga de requisições.
- **Ferramentas**:
  - **Lens**: Visualiza o Kong e os serviços no cluster, facilitando o monitoramento.
  - **kubectl** (ou `k`): Gerencia a implantação do Kong e atualizações no `kong.yml`.

## Próximas Aulas
- **Temas Futuros**:
  - Detalhamento da validação de JWTs no Kong e integração com o serviço de autenticação.
  - Configuração avançada de plugins (ex.: *rate limiting*, caching).
  - Estratégias para alta disponibilidade e monitoramento do API Gateway.
- **Objetivo**:
  - Corrigir erros no código do projeto (ex.: problemas com JWT).
  - Explorar a interface do Kong e sua integração com o projeto do GitHub.

## Conclusão
A aula introduz o **API Gateway** como um componente essencial para centralizar a comunicação em microserviços, usando o **Kong** para gerenciar requisições do front-end aos serviços de **Shortener**, **Analytics** e **Autenticação**. O Gateway simplifica a interação, valida JWTs, implementa *rate limiting* e encaminha dados como `X-User-Id`. O arquivo `kong.yml` define rotas e plugins, enquanto o projeto no GitHub e a pasta `docs` detalham a implementação. Desafios incluem configuração complexa e dependência do Gateway, resolvidos com alta disponibilidade e caching. A integração com Kubernetes reforça a escalabilidade, e as próximas aulas abordarão validação avançada e monitoramento.