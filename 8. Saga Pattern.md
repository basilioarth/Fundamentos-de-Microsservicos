# Resumo da Aula sobre Saga Pattern em Microserviços

## Introdução
A aula aborda o **Saga Pattern**, um padrão essencial em microserviços para gerenciar transações distribuídas e garantir consistência em fluxos complexos com múltiplos serviços. Diferentemente de transações tradicionais em bancos de dados, o Saga lida com operações assíncronas entre serviços, usando **ações de compensação** (rollback) para desfazer mudanças em caso de falhas. O exemplo utiliza um cenário de e-commerce e um caso prático de deleção de usuário nos serviços de **autenticação**, **encurtamento de URLs** e **analytics**, orquestrado por um componente centralizado. A implementação está no projeto do GitHub, com documentação detalhada na pasta `docs`, incluindo diagramas e explicações.

## Conceitos Fundamentais
- **Saga Pattern**:
  - Um padrão para gerenciar transações distribuídas em microserviços, onde uma operação envolve múltiplos serviços e pode falhar, exigindo ações de compensação (rollback).
  - **Diferença de um Monolito**: Em um monolito, transações usam commits/rollbacks atômicos no banco. Em microserviços, cada serviço tem seu próprio banco, exigindo coordenação via eventos assíncronos.
  - **Tipos de Saga**:
    - **Orquestrada**: Um orquestrador central gerencia os passos, enviando eventos e coordenando compensações.
    - **Coreografada**: Serviços reagem diretamente a eventos, sem um coordenador central (não abordada na aula).
- **Ações de Compensação**:
  - Cada operação em um serviço (ex.: criar pedido, emitir nota fiscal) tem uma ação oposta (ex.: cancelar pedido, desfazer nota fiscal) para reverter mudanças em caso de erro.
  - **Exemplo**: Se a emissão de uma nota fiscal falha devido a um CPF inválido, o pedido original deve ser cancelado.
- **Exemplo de Problema**:
  - **Cenário de E-commerce**:
    - Um pedido é criado no serviço de **Pedidos**.
    - Um evento `order.created` é enviado ao serviço de **Notas Fiscais** para emitir uma nota.
    - A emissão falha (ex.: CPF inválido), exigindo o cancelamento do pedido.
    - Se o serviço de Notas Fiscais chamar outro serviço (ex.: Serasa para pontuação), uma falha nesse serviço exige compensações em cascata (desfazer nota fiscal e pedido).
  - **Cenário do Projeto**:
    - Ao deletar um usuário no serviço de **Autenticação**, todas as URLs associadas (no Shortener) e seus analytics (no Analytics) devem ser removidos.
    - Se qualquer etapa falhar (ex.: falha ao deletar analytics), todas as ações anteriores (ex.: deleção de URLs) devem ser revertidas.
- **Solução: Saga Orquestrada**:
  - Um **orquestrador** gerencia os passos do Saga, enviando eventos para cada serviço e rastreando o estado em um banco.
  - Cada serviço executa sua ação (ex.: soft delete) e possui uma ação de compensação (ex.: restaurar dados).
  - O orquestrador garante que, em caso de erro, todas as ações concluídas sejam revertidas na ordem inversa.

## Exemplo Prático
- **Cenário: Deleção de Usuário**:
  - **Serviços Envolvidos**:
    - **Autenticação**: Gerencia a deleção da conta do usuário.
    - **Shortener**: Remove URLs associadas ao usuário.
    - **Analytics**: Remove dados de analytics das URLs.
  - **Fluxo do Saga**:
    1. O usuário solicita a deleção da conta via API (ex.: `/auth/delete-user`).
    2. O serviço de autenticação inicia um Saga via orquestrador, criando um workflow para a deleção.
    3. **Passo 1**: Envia evento `urlshortener.deleteUserUrls` ao Shortener para realizar um *soft delete* das URLs do usuário.
       - Compensação: `urlshortener.restoreUserUrls` (restaura URLs, definindo `deleted_at = null`).
    4. **Passo 2**: Envia evento `analytics.deleteUserAnalytics` ao Analytics para realizar um *soft delete* dos dados de analytics.
       - Compensação: `analytics.restoreUserAnalytics` (restaura analytics).
    5. **Passo 3**: Deleta a conta do usuário no serviço de autenticação (soft delete).
       - Compensação: `auth.restoreUserAccount` (restaura a conta, definindo `deleted_at = null`).
    6. Se qualquer passo falhar (ex.: falha no Analytics), o orquestrador executa as compensações dos passos anteriores na ordem inversa (restaura Analytics, URLs e conta).
  - **Orquestrador**:
    - Mantém um banco de dados com o estado do Saga (ex.: tabela `SagaSteps` com passos concluídos).
    - Envia eventos Kafka para cada serviço e rastreia sucessos/erros.
    - Em caso de erro, dispara eventos de compensação (ex.: `restoreUserUrls`, `restoreUserAnalytics`).
- **Resultado**:
  - Garante consistência: ou todos os passos são concluídos com sucesso, ou todas as ações são revertidas.
  - Usa *soft delete* (ex.: `deleted_at`) para facilitar restauração, em vez de exclusão permanente.

## Implementação no Código
- **Estrutura do Projeto**:
  - **Serviço de Autenticação**:
    - Rota `/auth/delete-user`: Inicia o Saga de deleção.
    - Orquestrador: Gerencia o workflow do Saga, enviando eventos Kafka e rastreando passos.
    - Funções: `handleDeleteUserAccount` (soft delete da conta) e `handleRestoreUserAccount` (restaura conta, `deleted_at = null`).
  - **Serviço Shortener**:
    - Consome evento `urlshortener.deleteUserUrls` e realiza *soft delete* das URLs.
    - Compensação: Consome `urlshortener.restoreUserUrls` para restaurar URLs.
  - **Serviço Analytics**:
    - Consome evento `analytics.deleteUserAnalytics` e realiza *soft delete* dos dados.
    - Compensação: Consome `analytics.restoreUserAnalytics` para restaurar dados.
  - **Orquestrador**:
    - Banco de dados armazena o estado do Saga (ex.: tabela `SagaSteps` com passos e status).
    - Workflow de deleção de usuário: Define passos (delete URLs, delete Analytics, delete conta) e compensações.
    - Exemplo: `Saga: UserDeletion` com passos:
      1. `urlshortener.deleteUserUrls` → Compensação: `urlshortener.restoreUserUrls`.
      2. `analytics.deleteUserAnalytics` → Compensação: `analytics.restoreUserAnalytics`.
      3. `auth.deleteUserAccount` → Compensação: `auth.restoreUserAccount`.
  - **Docs**: A pasta `docs` contém um diagrama sequencial do Saga e explicações sobre o orquestrador.
- **Código**:
  - **Autenticação**:
    - Inicia o Saga: `orchestrator.startSaga('UserDeletion', userId)`.
    - Envia eventos Kafka: `kafka.send('urlshortener.deleteUserUrls', { userId })`.
    - Compensação: `kafka.send('urlshortener.restoreUserUrls', { userId })` em caso de erro.
  - **Shortener**:
    - Consome evento: `if (event === 'deleteUserUrls') await db.urls.update({ deleted_at: now }, { where: { userId } });`.
    - Compensação: `if (event === 'restoreUserUrls') await db.urls.update({ deleted_at: null }, { where: { userId } });`.
  - **Analytics**: Similar ao Shortener, com *soft delete* e restauração.
  - **Orquestrador**:
    - Registra passos: `await SagaSteps.insert({ sagaId, step: 'deleteUserUrls', status: 'completed' })`.
    - Em erro: Dispara compensações na ordem inversa com base em `SagaSteps`.
- **Kafka**:
  - Usado para enviar eventos assíncronos (ex.: `deleteUserUrls`, `restoreUserUrls`).
  - Garante propagação confiável entre serviços.

## Desafios do Saga Pattern
1. **Complexidade de Orquestração**:
   - Configurar o orquestrador e rastrear estados em um banco é trabalhoso, especialmente em Node.js, que não tem bibliotecas avançadas para Sagas.
   - **Solução**: Usar frameworks como **NestJS**, que oferecem orquestradores automáticos, ou linguagens como Java/Go para cenários complexos.
2. **Consistência Eventual**:
   - Sagas operam com consistência eventual, não atômica, o que pode levar a estados temporariamente inconsistentes.
   - **Solução**: Usar *soft delete* para facilitar compensações e evitar perda de dados.
3. **Gestão de Erros**:
   - Falhas em um passo exigem compensações em todos os passos anteriores, aumentando a complexidade.
   - **Solução**: Armazenar o estado do Saga em uma tabela `SagaSteps` para rastrear passos concluídos.
4. **Escalabilidade**:
   - O orquestrador pode se tornar um gargalo em sistemas com muitas Sagas.
   - **Solução**: Escalar o orquestrador com Kubernetes e otimizar o banco de estados.
5. **Manutenção**:
   - Adicionar novos passos ou serviços ao Saga exige atualizar o orquestrador e as compensações.
   - **Solução**: Padronizar eventos e compensações em `contracts`.

## Boas Práticas
- **Orquestração Centralizada**:
  - Usar um orquestrador para gerenciar passos e compensações, armazenando estados em um banco (ex.: `SagaSteps`).
- **Soft Delete**:
  - Implementar deleções como *soft delete* (ex.: `deleted_at`) para facilitar restauração em compensações.
- **Eventos Padronizados**:
  - Definir eventos Kafka (ex.: `deleteUserUrls`, `restoreUserUrls`) em `contracts` com Zod ou JSON Schema.
- **Monitoramento**:
  - Integrar o Saga com **OpenTelemetry** para rastrear passos e compensações no Jaeger/Grafana.
  - Configurar alertas para falhas de Saga (ex.: via Prometheus).
- **Frameworks**:
  - Usar frameworks como **NestJS** para orquestração automática em Node.js.
  - Considerar Java/Go para orquestradores em sistemas complexos.
- **Documentação**:
  - Incluir diagramas sequenciais e detalhes do Saga na pasta `docs`.
  - Documentar passos e compensações em `contracts`.

## Relação com o Kubernetes
- **Conexão com o Módulo Anterior**:
  - O orquestrador e os serviços (Autenticação, Shortener, Analytics) são **Deployments** no Kubernetes.
  - **ConfigMaps** armazenam configurações do Saga (ex.: tópicos Kafka).
  - **Services** garantem comunicação entre o orquestrador e os serviços via Kafka.
  - **Secrets** gerenciam chaves sensíveis (ex.: credenciais do banco de estados).
  - **HPA** escala o orquestrador e os serviços com base na carga de eventos.
- **Ferramentas**:
  - **Lens**: Visualiza *Deployments*, *Services* e o banco de estados do Saga.
  - **kubectl** (ou `k`): Gerencia a implantação do orquestrador e atualizações.

## Relação com Outros Conceitos
- **Idempotência**:
  - O Saga complementa a idempotência, garantindo que eventos repetidos (ex.: `deleteUserUrls`) não causem duplicações, usando `event_id` para verificação.
- **Observabilidade**:
  - O `X-Request-Id` e o `event_id` do Saga são rastreados pelo OpenTelemetry, permitindo visualizar o fluxo do Saga no Jaeger/Grafana.
- **API Gateway**:
  - O API Gateway inicia o Saga (ex.: ao receber `/auth/delete-user`) e propaga o `X-Request-Id`.
- **Autenticação**:
  - O Saga pode usar o `user_id` (do JWT) para correlacionar deleções a usuários específicos.
- **Persistência**:
  - O banco do orquestrador (ex.: `SagaSteps`) e os bancos dos serviços (ex.: PostgreSQL, Redis) usam *soft delete* para suportar compensações.

## Próximas Aulas
- **Temas Futuros**:
  - Configuração avançada de Sagas com frameworks como NestJS.
  - Comparação entre Sagas orquestradas e coreografadas.
  - Otimização do orquestrador para alta escalabilidade.
- **Objetivo**:
  - Explorar a implementação do Saga no projeto do GitHub.
  - Aprofundar o monitoramento de Sagas com OpenTelemetry e Grafana.

## Conclusão
A aula apresenta o **Saga Pattern** como uma solução para transações distribuídas em microserviços, usando ações de compensação para lidar com falhas. O exemplo de deleção de usuário ilustra um Saga orquestrado, com passos para deletar URLs, analytics e a conta, revertendo ações via *soft delete* em caso de erro. O orquestrador gerencia o workflow, usando Kafka e um banco de estados (`SagaSteps`). O projeto no GitHub implementa o Saga, com documentação na pasta `docs`. Boas práticas incluem *soft delete*, eventos padronizados e monitoramento. A integração com Kubernetes e conceitos anteriores (idempotência, observabilidade) reforça a aplicabilidade, e as próximas aulas explorarão otimizações e frameworks.