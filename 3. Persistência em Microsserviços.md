# Resumo da Aula sobre Persistência de Dados em Microserviços

## Introdução
A aula aborda a **persistência de dados** em microserviços, um desafio tão significativo quanto a comunicação entre serviços. Cada microserviço deve ter sua própria estrutura de persistência (geralmente um banco de dados independente), o que implica em duplicação controlada de dados e gerenciamento de referências entre serviços. O exemplo usado envolve serviços de **pedidos**, **estoque** e **notas fiscais**, complementando o caso anterior de **encurtamento de URLs** e **analytics**. A aula destaca a importância de **referências suaves** (soft references) em vez de chaves estrangeiras e conecta os conceitos ao projeto prático no GitHub, com documentação detalhada.

## Conceitos Fundamentais
- **Persistência por Serviço**:
  - Cada microserviço deve ter seu próprio banco de dados ou estrutura de persistência.
  - **Regra**: Um serviço **não** pode acessar diretamente o banco de outro serviço, sob risco de quebrar a arquitetura de microserviços.
  - Exemplo: O serviço de **notas fiscais** (invoices) não acessa o banco do serviço de **pedidos** (orders) para obter dados do cliente.
- **Duplicação Controlada**:
  - Dados podem ser duplicados entre serviços, mas apenas os necessários para cada domínio.
  - Exemplo: O serviço de pedidos armazena dados completos do cliente (endereço, e-mail, documento, cartão de crédito), enquanto o serviço de notas fiscais armazena apenas endereço, e-mail e documento.
- **Referências Suaves (Soft References)**:
  - Usadas para correlacionar dados entre serviços, sem dependência direta via banco (como chaves estrangeiras).
  - Exemplo: O serviço de notas fiscais armazena um campo `orders_customer_id` que referencia o `customer_id` do serviço de pedidos.
- **Serviço Detentor**:
  - Um serviço é o "dono" principal de uma entidade (ex.: o serviço de pedidos cria e gerencia os dados do cliente).
  - Outros serviços mantêm cópias parciais, atualizadas via eventos (ex.: Kafka).

## Exemplo Prático
- **Cenário: Pedidos, Estoque e Notas Fiscais**:
  - **Serviço de Pedidos (Orders)**:
    - Banco de dados com tabela `customers` contendo: `customer_id`, endereço, e-mail, documento, dados de cartão.
    - Quando um pedido é criado, armazena os dados do cliente e emite um evento (ex.: `order.created`).
  - **Serviço de Notas Fiscais (Invoices)**:
    - Banco de dados com tabela `customers` contendo apenas: `orders_customer_id`, endereço, e-mail, documento.
    - Consome o evento `order.created` via Kafka para criar um registro na sua tabela `customers`.
  - **Comunicação**:
    - O serviço de pedidos publica um evento com os dados do cliente (ex.: `customer_id: 123`, endereço, e-mail, documento).
    - O serviço de notas fiscais ouve o evento e armazena apenas os dados necessários, usando `orders_customer_id` como referência.
- **Exemplo do Projeto (URL Shortener e Analytics)**:
  - **URL Shortener**:
    - Banco de dados com tabela `urls` (ex.: `id`, `shortcode`, `url_original`, `click_count`).
    - Ao criar uma URL, publica um evento `shortener.url.created` no Kafka.
  - **Analytics**:
    - Banco de dados com tabela `url_creations` (ex.: `shortener_url_id`, outros dados para rastrear cliques).
    - Consome o evento `shortener.url.created` e registra a URL no seu banco.
  - **Atualizações**:
    - Se o cliente for modificado no serviço de pedidos (ex.: endereço alterado), um evento `order.customer.updated` é publicado.
    - O serviço de notas fiscais atualiza sua tabela `customers` com base nesse evento.

## Desafios da Persistência Distribuída
1. **Duplicação de Dados**:
   - Dados são replicados parcialmente entre serviços, o que exige sincronização via eventos.
   - Exemplo: O serviço de notas fiscais não armazena dados de cartão, mas precisa do endereço e documento.
2. **Consistência Eventual**:
   - Como os dados são atualizados via eventos assíncronos, pode haver atraso na propagação (ex.: Analytics pode estar desatualizado temporariamente).
   - Solução: Usar *message brokers* como Kafka para garantir entrega confiável.
3. **Referências sem Chaves Estrangeiras**:
   - **Soft References**: Campos como `orders_customer_id` não são chaves estrangeiras, pois não há validação direta no banco.
   - **Desafio**: Garantir que a referência (ex.: `customer_id`) exista no serviço detentor.
   - **Risco**: Se o serviço detentor apagar um registro, outros serviços podem ficar com referências órfãs.
4. **Gerenciamento de Eventos**:
   - Atualizações em um serviço (ex.: mudança de endereço do cliente) devem ser propagadas via eventos para manter a consistência.
   - Exemplo: Um evento `order.customer.updated` atualiza o endereço no serviço de notas fiscais.
5. **Complexidade Operacional**:
   - Cada serviço requer seu próprio esquema de banco, aumentando a complexidade de manutenção.
   - Necessidade de monitoramento para garantir que eventos sejam processados corretamente.

## Implementação no Código
- **Estrutura do Projeto**:
  - **Serviços**:
    - `apps/shortener`: Gerencia URLs com tabela `urls`.
    - `apps/analytics`: Gerencia métricas com tabela `url_creations`.
  - **Contracts**: Define esquemas de eventos (ex.: `UrlCreatedEvent`) usando **Zod** para tipagem.
  - **Docs**: Pasta com documentação detalhada sobre comunicação e persistência.
- **Persistência no URL Shortener**:
  - Tabela `urls`: Armazena `id`, `shortcode`, `url_original`, `click_count`.
  - Após criar uma URL, publica o evento `shortener.url.created` no Kafka.
- **Persistência no Analytics**:
  - Tabela `url_creations`: Armazena `shortener_url_id` (referência ao ID do Shortener) e outros dados.
  - Consome o evento `shortener.url.created` para registrar a URL no banco.
- **Referências Suaves**:
  - O campo `shortener_url_id` no Analytics referencia o `id` da tabela `urls` do Shortener, sem ser uma chave estrangeira.
- **Documentação**:
  - A pasta `docs` explica:
    - **Comunicação Assíncrona**: Fluxo de eventos via Kafka (ex.: `shortener.url.created`).
    - **Persistência Distribuída**: Cada serviço com seu banco e uso de *soft references*.
  - Inclui detalhes sobre *referential integrity* e por que chaves estrangeiras não são usadas.

## Boas Práticas
- **Banco de Dados por Serviço**:
  - Cada microserviço deve ter seu próprio banco, isolado dos demais.
  - Exemplo: O serviço de pedidos usa PostgreSQL, enquanto o de notas fiscais pode usar MongoDB.
- **Duplicação Mínima**:
  - Armazenar apenas os dados necessários em cada serviço (ex.: notas fiscais não precisa de dados de cartão).
- **Soft References**:
  - Usar campos como `orders_customer_id` para correlacionar dados, prefixando com o nome do serviço detentor.
  - Evitar chaves estrangeiras para manter a independência dos bancos.
- **Eventos para Sincronização**:
  - Usar eventos (ex.: `order.customer.updated`) para propagar alterações entre serviços.
  - Configurar retenção longa no Kafka (ex.: 6 meses) para reprocessamento em falhas.
- **Documentação Clara**:
  - Centralizar esquemas de eventos e dados em `contracts` (usando **Zod** ou **JSON Schema**).
  - Manter documentação detalhada (ex.: pasta `docs`) para facilitar manutenção.
- **Monitoramento**:
  - Monitorar o processamento de eventos no Kafka para detectar falhas (ex.: mensagens não consumidas).
  - Usar ferramentas como **Prometheus** e **Grafana** para observar a saúde dos bancos e *brokers*.
- **Evitar Acoplamento**:
  - Nunca permitir que um serviço acesse diretamente o banco de outro.
  - Toda sincronização deve ocorrer via eventos ou APIs.

## Relação com o Kubernetes
- **Conexão com o Módulo Anterior**:
  - Cada serviço (ex.: Orders, Invoices) é implantado como um **Deployment** no Kubernetes.
  - **ConfigMaps** e **Secrets** armazenam configurações de bancos (ex.: URLs de conexão).
  - **Services** facilitam a comunicação entre microserviços (ex.: via Kafka ou gRPC).
  - **HPA** (Horizontal Pod Autoscaler) pode escalar serviços com base na carga do banco ou volume de eventos.
- **Ferramentas**:
  - **Lens**: Visualiza bancos e serviços no cluster, útil para verificar a saúde dos *Deployments*.
  - **kubectl** (ou `k`): Gerencia a implantação e configuração dos serviços e bancos.

## Próximas Aulas
- **Temas Futuros**:
  - Exemplos avançados de persistência distribuída (ex.: cenários com múltiplos serviços).
  - Estratégias para lidar com consistência eventual e reprocessamento de eventos.
  - Configuração de CI/CD e monitoramento para sistemas distribuídos.
- **Objetivo**:
  - Aprofundar a implementação prática no projeto do GitHub.
  - Explorar desafios como *referential integrity* e escalabilidade de bancos.

## Conclusão
A aula aborda a persistência de dados em microserviços, destacando a necessidade de bancos independentes por serviço e a duplicação controlada de dados. O exemplo de **pedidos** e **notas fiscais** ilustra como usar *soft references* (ex.: `orders_customer_id`) para correlacionar dados sem chaves estrangeiras, com sincronização via eventos Kafka. No projeto do GitHub, o **URL Shortener** e **Analytics** demonstram a persistência distribuída, com documentação na pasta `docs`. Boas práticas incluem duplicação mínima, eventos para sincronização, e monitoramento robusto. A integração com Kubernetes reforça a aplicabilidade, e as próximas aulas explorarão cenários mais complexos e estratégias de gerenciamento.