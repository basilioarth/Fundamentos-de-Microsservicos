# Resumo da Aula sobre Comunicação entre Microserviços

## Introdução
A aula aborda a comunicação entre microserviços, um aspecto crucial para garantir sua independência e funcionamento isolado. O instrutor apresenta um projeto público no GitHub, implementado em **Node.js** com **TypeScript**, que será usado para ilustrar os conceitos teóricos na prática. A construção do código do zero é evitada para focar nos conceitos específicos de microserviços, como comunicação síncrona (HTTP, gRPC) e assíncrona (Kafka, RabbitMQ). O exemplo principal continua sendo o sistema de **encurtamento de URLs** e **analytics**, destacando como os serviços se comunicam e os desafios envolvidos.

## Contexto
- **Projeto de Exemplo**:
  - Disponível no GitHub (link fornecido pelo instrutor).
  - Implementa microserviços em **Node.js** com **TypeScript**, incluindo:
    - **URL Shortener**: Serviço para criar URLs encurtadas.
    - **Analytics**: Serviço para rastrear cliques e métricas.
  - O código é refatorado durante as aulas, então os arquivos podem mudar.
- **Abordagem**:
  - Teoria: Explicação dos conceitos de comunicação entre microserviços.
  - Prática: Demonstração no código, sem construir tudo do zero, para evitar detalhes não relacionados a microserviços.
- **Objetivo**:
  - Ensinar como microserviços se comunicam de forma independente, usando protocolos síncronos e assíncronos.
  - Garantir que a falha de um serviço (ex.: Analytics) não afete outros (ex.: Shortener), ao contrário de um monolito.

## Comunicação entre Microserviços
- **Independência**:
  - Microserviços devem operar isoladamente. Exemplo: O serviço de encurtamento de URLs deve criar URLs mesmo se o serviço de Analytics estiver fora do ar.
  - Em um monolito, a falha de uma parte (ex.: Analytics) compromete todo o sistema.
- **Protocolos de Comunicação**:
  - **Síncrona**: Usada quando a resposta imediata é necessária (ex.: HTTP, gRPC).
  - **Assíncrona**: Preferida para maior resiliência, usando *message brokers* como **Kafka** ou **RabbitMQ**.
- **Exemplo Prático**:
  - **Cenário 1: Encurtamento de URLs**:
    - O serviço de Shortener cria uma URL e notifica o Analytics para registrar a URL no banco de dados.
    - Comunicação assíncrona é ideal, pois a criação da URL não depende do Analytics estar online.
  - **Cenário 2: Sistema de Pedidos e Estoque**:
    - Um serviço de pedidos consulta o serviço de estoque em tempo real para verificar disponibilidade.
    - Comunicação síncrona (HTTP ou gRPC) é necessária, pois o pedido depende da resposta imediata do estoque.

### Comunicação Síncrona
- **HTTP**:
  - Usado para chamadas diretas entre serviços (ex.: Shortener envia requisição ao Analytics).
  - **Desvantagem**:
    - Se o serviço de destino (ex.: Analytics) estiver fora do ar, a requisição falha (ex.: status 400 ou 500).
    - Isso pode propagar o erro ao cliente (ex.: front-end que criou a URL).
  - **Uso**: Casos onde a resposta imediata é menos crítica, mas ainda necessária.
- **gRPC**:
  - Baseado em **HTTP/2** e **Protocol Buffers (protobuf)**, que define a estrutura das chamadas de forma tipada.
  - **Vantagens**:
    - Tipagem forte: Evita erros em parâmetros ou respostas.
    - Maior eficiência que HTTP/1.1, devido ao HTTP/2.
  - **Uso**: Ideal para cenários que exigem comunicação síncrona em tempo real (ex.: verificar estoque para um pedido).
  - **Exemplo**: No sistema de pedidos, o serviço de pedidos usa gRPC para consultar o estoque, garantindo resposta rápida e tipada.

### Comunicação Assíncrona
- **Ferramentas**:
  - **Kafka**: Mais comum, usa um banco de dados interno para armazenar mensagens.
  - **RabbitMQ**: Também amplamente usado, semelhante ao Kafka.
  - **Redis**: Menos recomendado para mensageria, usado em casos específicos.
- **Padrão Publish/Subscribe**:
  - **Publish**: Um serviço (ex.: Shortener) publica uma mensagem em um *message broker* (ex.: Kafka).
  - **Subscribe**: Outro serviço (ex.: Analytics) se inscreve para consumir mensagens específicas.
  - **Exemplo**:
    - Shortener publica um evento `url.created` no Kafka com dados da URL (ex.: JSON com `id`, `shortcode`).
    - Analytics se inscreve no tópico `shortener.url.created` e processa as mensagens para registrar no banco.
- **Funcionamento do Kafka**:
  - **Tópicos**: Funcionam como "tabelas" que organizam mensagens por tipo de evento (ex.: `shortener.url.created`).
  - **Banco de Dados**: Armazena mensagens por um período configurável (ex.: 6 meses), permitindo reprocessamento.
  - **Consumer Groups**: Identificam consumidores (ex.: Analytics como `consumer_group: analytics`).
    - Quando o Analytics consome uma mensagem, o Kafka marca que o *consumer group* a processou, sem deletá-la.
    - Outro serviço pode consumir a mesma mensagem como um *consumer group* diferente.
  - **Resiliência**:
    - Se o Analytics estiver offline por um mês, ao voltar, ele consome todas as mensagens acumuladas no Kafka.
    - Mensagens críticas (ex.: pedidos, notas fiscais) podem ser reprocessadas se necessário.
- **Vantagens**:
  - **Desacoplamento**: O Shortener não depende do Analytics estar online.
  - **Escalabilidade**: Mensagens são processadas em tempo quase real, mas persistem no *broker* para falhas.
  - **Flexibilidade**: Suporta reprocessamento e múltiplos consumidores.

## Implementação no Código
- **Estrutura do Projeto**:
  - **Serviços**:
    - `apps/shortener`: Serviço de encurtamento de URLs.
    - `apps/analytics`: Serviço de analytics.
  - **Contracts**: Diretório com definições de eventos (ex.: `url.created`) para padronizar a comunicação.
- **Tipagem com TypeScript e Zod**:
  - **Contracts**: Usam **Zod** para definir esquemas de eventos (ex.: `UrlCreatedEvent` com campos obrigatórios e opcionais).
  - **JSON Schema**: Alternativa para projetos multi-linguagem, garantindo compatibilidade entre serviços.
  - Exemplo: `UrlCreatedEvent` define o formato da mensagem (ex.: `id`, `shortcode`, `url_original`).
- **Publicação de Eventos**:
  - No Shortener, após criar uma URL, a rota chama `publishUrlCreatedEvent`, que envia um evento ao Kafka.
  - Exemplo: `kafka.publish('shortener.url.created', { id, shortcode, url })`.
- **Consumo de Eventos**:
  - No Analytics, um *consumer* (`UrlCreatedEventConsumer`) se inscreve no tópico `shortener.url.created`.
  - O *consumer* processa a mensagem, cadastrando a URL no banco de dados do Analytics.
  - Estrutura: Um objeto `ConsumedEvents` lista os eventos consumidos (ex.: `url.created`, `url.clicked`).
- **Boa Prática**:
  - Documentar eventos em *contracts* para garantir consistência.
  - Usar tipagem (Zod ou JSON Schema) para evitar erros de formato.
  - Prefixar tópicos com o nome do serviço (ex.: `shortener.url.created`) para organização.

## Boas Práticas
- **Priorizar Comunicação Assíncrona**:
  - Usar Kafka ou RabbitMQ para cenários onde a resposta imediata não é necessária (ex.: notificar criação de URLs).
  - Reservar HTTP/gRPC para casos críticos que exigem resposta em tempo real (ex.: verificar estoque).
- **Tipagem e Contratos**:
  - Definir esquemas claros para eventos (ex.: com **Zod** ou **JSON Schema**) para evitar erros de comunicação.
  - Centralizar definições em um diretório `contracts` para reutilização.
- **Tópicos no Kafka**:
  - Usar nomes descritivos (ex.: `shortener.url.created`) para facilitar manutenção.
  - Configurar retenção de mensagens (ex.: 6 meses) para cenários críticos.
- **Resiliência**:
  - Configurar *consumer groups* para permitir reprocessamento e múltiplos consumidores.
  - Garantir que falhas em um serviço não afetem outros, usando *brokers* para armazenar mensagens.
- **Monitoramento**:
  - Monitorar a latência e o processamento de mensagens no Kafka/RabbitMQ.
  - Usar ferramentas como **Prometheus** e **Grafana** para observar a saúde dos *brokers*.
- **Evitar Acoplamento**:
  - Não permitir que um serviço acesse diretamente o banco de dados de outro.
  - Toda comunicação deve passar por APIs (HTTP/gRPC) ou *message brokers* (Kafka/RabbitMQ).

## Relação com o Kubernetes
- **Conexão com o Módulo Anterior**:
  - Cada microserviço (Shortener, Analytics) é implantado como um **Deployment** no Kubernetes.
  - **Services** do Kubernetes facilitam a comunicação HTTP/gRPC entre microserviços.
  - **ConfigMaps** e **Secrets** (vistos anteriormente) armazenam configurações do Kafka (ex.: endereço do *broker*).
  - **HPA** pode ser configurado para escalar o Analytics com base no volume de mensagens no Kafka.
- **Ferramentas**:
  - **Lens** (mencionado na aula anterior) visualiza os **Deployments** e **Services** dos microserviços.
  - **kubectl** (ou `k`) gerencia a implantação e monitoramento dos serviços no cluster.

## Próximas Aulas
- **Temas Futuros**:
  - Aprofundamento na implementação de comunicação assíncrona (Kafka, RabbitMQ).
  - Configuração de CI/CD para múltiplos microserviços.
  - Estratégias para consistência de dados e observabilidade em sistemas distribuídos.
- **Objetivo**:
  - Explorar mais detalhes do código no projeto do GitHub.
  - Abordar desafios práticos, como latência, reprocessamento de mensagens, e monitoramento.

## Conclusão
A aula explora a comunicação entre microserviços, enfatizando a independência dos serviços e o uso de protocolos síncronos (HTTP, gRPC) e assíncronos (Kafka, RabbitMQ). O exemplo de encurtamento de URLs e analytics ilustra a publicação de eventos (`url.created`) no Kafka e seu consumo pelo Analytics, com tipagem via **Zod** para garantir consistência. A comunicação assíncrona é preferida para resiliência, enquanto HTTP/gRPC é usado em cenários que exigem resposta imediata. O projeto no GitHub complementa a teoria, e boas práticas incluem tipagem, tópicos organizados, e resiliência via *consumer groups*. A integração com Kubernetes reforça a aplicabilidade dos conceitos, preparando para aulas futuras sobre implementação prática e gerenciamento de microserviços.