# Resumo da Aula sobre Autenticação em Microserviços

## Introdução
A aula aborda o desafio da **autenticação** em microserviços, destacando a necessidade de um serviço centralizado para gerenciar autenticação e evitar que os usuários precisem se autenticar separadamente em cada serviço. O exemplo continua com os serviços de **encurtamento de URLs** e **analytics**, introduzindo um serviço de **autenticação** que utiliza **JWT** (JSON Web Tokens) com algoritmos simétricos e assimétricos. A aula explora estratégias como **JWKS** para distribuir chaves públicas e conecta os conceitos ao projeto prático no GitHub, com documentação detalhada.

## Conceitos Fundamentais
- **Autenticação Centralizada**:
  - Em uma arquitetura de microserviços, um serviço dedicado de **autenticação** gerencia a criação de tokens (ex.: JWT) ou sessões.
  - Outros serviços (ex.: Shortener, Analytics) apenas validam os tokens, sem gerá-los.
  - **Motivo**: Evitar autenticação redundante para o usuário em cada serviço (ex.: criar URL ou consultar cliques requer autenticação única).
- **JWT (JSON Web Tokens)**:
  - Padrão para autenticação, contendo informações codificadas (ex.: usuário, permissões) assinadas por uma chave.
  - Dois tipos de algoritmos:
    - **Simétrico** (ex.: HS256): Usa uma única chave secreta (*secret*) para gerar e validar tokens.
    - **Assimétrico** (ex.: RS256, RS512): Usa uma chave privada para gerar tokens e uma chave pública para validação.
- **Algoritmo Simétrico (HS256)**:
  - **Funcionamento**: O *secret* é compartilhado entre o serviço de autenticação e outros serviços (Shortener, Analytics) via variáveis de ambiente.
  - **Problema**:
    - O *secret* é sensível, pois pode ser usado para criar tokens fraudulentos.
    - Compartilhar o *secret* em múltiplos serviços (ex.: 500 serviços) aumenta o risco de vazamento.
    - Atualizar o *secret* exige alterações em todos os serviços, demandando novos deploys.
- **Algoritmo Assimétrico (RS256, RS512)**:
  - **Funcionamento**:
    - **Chave Privada**: Mantida apenas no serviço de autenticação para gerar tokens.
    - **Chave Pública**: Distribuída a outros serviços e ao front-end para validar tokens.
    - A chave pública **não** permite criar tokens, apenas verificar sua validade.
  - **Vantagem**: Maior segurança, pois a chave privada fica isolada.
  - **Uso**: Comum em SSH, certificados digitais, e emissão de notas fiscais.
- **JWKS (JSON Web Key Set)**:
  - Estratégia para distribuir chaves públicas dinamicamente.
  - O serviço de autenticação expõe um endpoint (ex.: `/jwks`) que retorna a chave pública.
  - Outros serviços (Shortener, Analytics) consultam o endpoint para obter a chave pública e validar tokens.
  - **Vantagem**: Evita armazenar chaves públicas em variáveis de ambiente, facilitando atualizações sem novos deploys.
- **Fluxo de Autenticação**:
  - O cliente envia uma requisição com um JWT (ex.: ao criar uma URL ou consultar cliques).
  - O serviço (ex.: Analytics) consulta o endpoint `/jwks` do serviço de autenticação para obter a chave pública.
  - Com a chave pública, valida o JWT. Se válido, permite a operação; caso contrário, rejeita (ex.: status 401).

## Exemplo Prático
- **Cenário: Autenticação nos Serviços Shortener e Analytics**:
  - **Serviço de Autenticação**:
    - Gera JWTs usando uma chave privada (RS256 em produção, HS256 em desenvolvimento).
    - Expõe um endpoint `/jwks` que retorna a chave pública.
    - Gerencia registro e autenticação de usuários (ex.: hash de senhas com **Argon**).
  - **Serviço de Shortener**:
    - Requer autenticação para criar URLs.
    - Valida o JWT do cliente consultando o endpoint `/jwks` do serviço de autenticação.
  - **Serviço de Analytics**:
    - Requer autenticação para consultar cliques de URLs.
    - Valida o JWT da mesma forma, usando a chave pública obtida via `/jwks`.
- **Fluxo**:
  - O cliente autentica-se no serviço de autenticação, recebendo um JWT.
  - O cliente envia o JWT em requisições para Shortener ou Analytics.
  - Cada serviço valida o JWT chamando o endpoint `/jwks` e permite ou nega a operação.

## Implementação no Código
- **Estrutura do Projeto**:
  - **Serviço de Autenticação**:
    - Arquivo `.env`: Contém o `JWT_SECRET` (usado com HS256 em desenvolvimento).
    - Rota `/jwks`: Retorna a chave pública (em produção, com RS256).
    - Usa **Argon** para hash de senhas.
  - **Serviços Shortener e Analytics**:
    - Consultam o endpoint `/jwks` do serviço de autenticação para validar JWTs.
    - Rotas protegidas verificam a autenticação antes de processar requisições.
  - **Docs**: Pasta com documentação detalhada sobre o fluxo de autenticação e uso de JWKS.
- **Detalhes**:
  - Em desenvolvimento, usa HS256 (chave simétrica) para simplicidade.
  - Em produção, recomenda-se RS256 (chave assimétrica) para segurança.
  - A validação de JWTs será detalhada na próxima aula, devido à dependência de outros conceitos (ex.: integração com **Kong**).

## Desafios da Autenticação
1. **Gerenciamento de Chaves Simétricas**:
   - Compartilhar o *secret* (HS256) em múltiplos serviços é inseguro e difícil de manter.
   - Atualizações do *secret* exigem reconfiguração e deploy de todos os serviços.
2. **Distribuição de Chaves Públicas (RS256)**:
   - Mesmo com chaves assimétricas, armazenar chaves públicas em variáveis de ambiente exige novos deploys para atualizações.
   - Solução: Usar JWKS para consultar chaves dinamicamente.
3. **Escalabilidade**:
   - Em arquiteturas com muitos serviços (ex.: 500), gerenciar chaves manualmente é inviável.
   - JWKS reduz a complexidade ao centralizar a distribuição de chaves públicas.
4. **Segurança**:
   - A chave privada deve ser protegida no serviço de autenticação.
   - Vazamentos de chaves (simétricas ou públicas) podem comprometer a segurança.
5. **Dependência do Serviço de Autenticação**:
   - Se o serviço de autenticação estiver fora do ar, a validação de tokens pode falhar.
   - Solução: Cache local das chaves públicas (com TTL) para lidar com indisponibilidade temporária.

## Boas Práticas
- **Serviço de Autenticação Centralizado**:
  - Usar um serviço dedicado para gerar JWTs e gerenciar autenticação.
  - Outros serviços apenas validam tokens, nunca os criam.
- **Algoritmos Assimétricos (RS256)**:
  - Preferir RS256 ou RS512 em produção para maior segurança.
  - Manter a chave privada isolada no serviço de autenticação.
- **Uso de JWKS**:
  - Implementar um endpoint `/jwks` para distribuir chaves públicas dinamicamente.
  - Evitar armazenar chaves públicas em variáveis de ambiente.
- **Cache de Chaves Públicas**:
  - Armazenar chaves públicas em cache local (com tempo de expiração) para reduzir chamadas ao serviço de autenticação.
- **Monitoramento**:
  - Monitorar o endpoint `/jwks` e a saúde do serviço de autenticação com ferramentas como **Prometheus** e **Grafana**.
  - Registrar falhas de validação de JWTs para debugging.
- **Documentação**:
  - Incluir detalhes do fluxo de autenticação na pasta `docs` do projeto.
  - Documentar esquemas de JWTs e endpoints em `contracts` (ex.: com **Zod** ou **JSON Schema**).
- **Segurança**:
  - Usar algoritmos seguros para hash de senhas (ex.: **Argon**).
  - Proteger variáveis de ambiente (ex.: `JWT_SECRET`) com **Secrets** no Kubernetes.

## Relação com o Kubernetes
- **Conexão com o Módulo Anterior**:
  - O serviço de autenticação é implantado como um **Deployment** no Kubernetes.
  - **Services** do Kubernetes permitem que Shortener e Analytics acessem o endpoint `/jwks`.
  - **Secrets** armazenam a chave privada do serviço de autenticação (ex.: `JWT_SECRET`).
  - **HPA** pode escalar o serviço de autenticação com base na carga de requisições.
- **Ferramentas**:
  - **Lens**: Visualiza o serviço de autenticação e suas interações no cluster.
  - **kubectl** (ou `k`): Gerencia a implantação e configuração do serviço de autenticação.

## Próximas Aulas
- **Temas Futuros**:
  - Detalhamento da validação de JWTs nos serviços (ex.: integração com **Kong**).
  - Configuração de gateways de API para gerenciar autenticação centralizada.
  - Estratégias para lidar com falhas no serviço de autenticação.
- **Objetivo**:
  - Explorar a implementação prática no projeto do GitHub.
  - Aprofundar conceitos como cache de chaves e monitoramento de autenticação.

## Conclusão
A aula aborda a autenticação em microserviços, enfatizando a necessidade de um serviço centralizado para gerar JWTs e a validação distribuída nos demais serviços. O uso de algoritmos assimétricos (RS256) e **JWKS** resolve problemas de segurança e escalabilidade, evitando o compartilhamento de chaves sensíveis. O exemplo de **Shortener** e **Analytics** ilustra a validação de JWTs via chave pública, com detalhes no projeto do GitHub e documentação na pasta `docs`. Boas práticas incluem o uso de RS256, JWKS, cache de chaves, e monitoramento robusto. A integração com Kubernetes reforça a aplicabilidade, e as próximas aulas detalharão a validação e integração com gateways.