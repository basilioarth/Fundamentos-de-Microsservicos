# Resumo da Aula sobre Fundamentos de Microserviços

## Introdução
A aula introduz os fundamentos de microserviços, com foco em desmistificar conceitos, abordar mitos, vantagens e desafios. Microserviços são apresentados como uma arquitetura de infraestrutura, não de código, destacando sua independência e modelagem em torno de domínios de negócio. A aula enfatiza a relação com **Domain-Driven Design (DDD)**, especialmente os **Bounded Contexts**, e explora um exemplo prático de microserviços para encurtamento de URLs e analytics, ilustrando separação de serviços, tecnologias e escalabilidade.

## Conceitos Fundamentais
- **Definição de Microserviços**:
  - Uma arquitetura de **infraestrutura** que organiza aplicações em serviços independentes, implantáveis separadamente.
  - Cada serviço é focado em um **domínio de negócio** específico, com possibilidade de usar tecnologias e bancos de dados distintos (ex.: MongoDB, PostgreSQL, Redis; Go, Node.js, Java).
  - **Independência**: Se um serviço falhar, os outros continuam funcionando, embora o serviço afetado pare de processar seus eventos.
- **Relação com o Código**:
  - Microserviços **não** dependem diretamente da arquitetura de código, mas sim de como os serviços são implantados e gerenciados.
  - A separação é guiada por **Bounded Contexts** do **DDD**, que definem fronteiras claras para domínios de negócio, com regras e terminologias específicas.
- **Bounded Contexts**:
  - Cada contexto tem um modelo de domínio próprio, com significados distintos (ex.: "produto" em vendas é uma oferta; em estoque, é um item físico).
  - Essencial para aplicações grandes (ex.: ERPs, CRMs, e-commerces) com múltiplos times e domínios (atendimento, financeiro, faturamento, produto).
- **Independência de Deploy**:
  - Cada serviço tem seu próprio pipeline de **deploy**, permitindo atualizações sem impactar outros serviços.
  - Exemplo: Um serviço de encurtamento de URLs pode ser atualizado sem afetar o serviço de analytics.

## Exemplo Prático: Encurtamento de URLs
- **Estrutura**:
  - **Serviço de Encurtamento (Shortener)**:
    - Armazena URLs originais e seus shortcodes em um banco simples (ex.: MongoDB).
    - Exemplo: Tabela com `link_original` e `shortcode` (ex.: `encurta.com/abc123` redireciona para o link original).
  - **Serviço de Analytics**:
    - Registra métricas de acesso (ex.: navegador, IP, sistema operacional).
    - Usa banco otimizado para *time series* (ex.: ClickHouse, baseado em PostgreSQL).
- **Comunicação**:
  - O serviço de encurtamento notifica o serviço de analytics quando uma URL é criada, usando protocolos como HTTP, gRPC, ou assíncronos (Kafka, RabbitMQ, Redis).
  - Exemplo: Analytics mantém uma tabela `url_clicks` com `url_id` (referência ao ID no MongoDB do Shortener) e `click_count`.

## Vantagens dos Microserviços
1. **Infraestrutura Específica por Serviço**:
   - Cada serviço usa tecnologias adequadas às suas necessidades (ex.: MongoDB para Shortener, ClickHouse para Analytics).
   - Flexibilidade para escolher bancos, linguagens e frameworks por serviço.
2. **Escalabilidade Direcionada**:
   - Serviços são escalados individualmente com base na demanda.
   - Exemplo: O serviço de Analytics, com 100 milhões de acessos, pode rodar em 4 máquinas (1.4 vCPU, 256 MB RAM cada), enquanto o Shortener opera com uma única máquina para criação de URLs.
   - **Escalamento Horizontal**: Adicionar mais instâncias do serviço sobrecarregado sem escalar os demais.
3. **Desenvolvimento Paralelo**:
   - Em empresas grandes (ex.: 500-600 desenvolvedores), microserviços evitam conflitos em repositórios monolíticos (ex.: pull requests, branches).
   - Times trabalham em serviços independentes, com deploys isolados, reduzindo riscos e agilizando o desenvolvimento.
4. **Resiliência**:
   - A falha de um serviço não compromete os demais, garantindo continuidade parcial do sistema.

## Desafios dos Microserviços
1. **Complexidade Distribuída**:
   - Problemas de um monolito (latência, debugging, observabilidade, tracing, transações) são multiplicados pelo número de serviços (**O(n)**).
   - Exemplo: Monitoramento de logs, CPU, e memória deve ser feito para cada serviço individualmente.
2. **Consistência de Dados**:
   - Comunicação entre serviços exige sincronização de dados.
   - Exemplo: Se o Shortener atualiza um `shortcode`, o Analytics deve refletir essa mudança, o que é desafiador com muitos serviços (50, 100, 1000).
   - **Regra**: Cada serviço deve ter seu próprio banco de dados; um serviço não deve acessar diretamente o banco de outro, sob risco de quebrar a arquitetura de microserviços.
3. **Comunicação entre Serviços**:
   - Usa protocolos como **HTTP**, **gRPC** (síncronos) ou **Kafka**, **RabbitMQ**, **Redis** (assíncronos).
   - Gerenciar a comunicação aumenta a complexidade, especialmente em sistemas com muitos serviços.
4. **CI/CD e Monitoramento**:
   - Cada serviço requer pipelines de CI/CD próprios, aumentando a carga de configuração.
   - Monitoramento (logs, métricas, tracing) é necessário para cada serviço, exigindo ferramentas robustas.
5. **Manutenção em Times Grandes**:
   - Embora facilite o trabalho paralelo, exige coordenação rigorosa para manter a consistência e evitar duplicação de esforços.

## Boas Práticas
- **Modelagem por Domínio**:
  - Usar **Bounded Contexts** do **DDD** para definir serviços com base em domínios de negócio claros (ex.: vendas, estoque, faturamento).
  - Evitar sobreposições de responsabilidades entre serviços.
- **Independência de Dados**:
  - Cada serviço deve ter seu próprio banco de dados, com comunicação via APIs ou mensageria, nunca acessando diretamente o banco de outro serviço.
- **Escalabilidade Direcionada**:
  - Configurar **HPA** (Horizontal Pod Autoscaler, visto no módulo anterior) por serviço para escalar apenas os serviços sob alta demanda.
- **Monitoramento e Observabilidade**:
  - Usar ferramentas como **Prometheus**, **Grafana**, e **Jaeger** para monitoramento e tracing distribuído.
  - Centralizar logs para facilitar debugging.
- **Comunicação Clara**:
  - Definir protocolos de comunicação (HTTP, gRPC, Kafka) com base nas necessidades (síncrono ou assíncrono).
  - Documentar APIs e eventos para garantir integração fluida.
- **Evitar Microserviços Prematuros**:
  - Só adotar microserviços em sistemas grandes, com times numerosos e domínios complexos.
  - Monolitos são mais simples para sistemas menores ou equipes reduzidas.

## Relação com o Kubernetes
- **Conexão com o Módulo Anterior**:
  - Microserviços se alinham com o Kubernetes, onde cada serviço é implantado como um **Deployment** com **Pods** independentes.
  - Recursos como **Service**, **ConfigMap**, **Secret**, e **HPA** (vistos anteriormente) suportam a escalabilidade e configuração de microserviços.
  - Exemplo: O serviço de Shortener pode ter um **Deployment** com uma réplica, enquanto o Analytics usa **HPA** para escalar com base em acessos.
- **Ferramentas do Kubernetes**:
  - **Lens** (mencionado na aula anterior) facilita a visualização de múltiplos serviços no cluster.
  - **kubectl** (ou alias `k`) é usado para gerenciar deploys de cada serviço.

## Próximas Aulas
- **Temas Futuros**:
  - Comunicação entre microserviços (HTTP, gRPC, Kafka, RabbitMQ).
  - Estratégias para consistência de dados em sistemas distribuídos.
  - Configuração de CI/CD e monitoramento para múltiplos serviços.
- **Objetivo**:
  - Aprofundar os desafios técnicos (ex.: latência, tracing, transações).
  - Explorar ferramentas e práticas para gerenciar microserviços em produção.

## Conclusão
A aula introduz microserviços como uma arquitetura de infraestrutura, focada em serviços independentes modelados por domínios de negócio, com forte relação com **DDD** e **Bounded Contexts**. O exemplo de encurtamento de URLs e analytics ilustra a separação de serviços, com tecnologias distintas (MongoDB, ClickHouse) e escalabilidade direcionada. As vantagens incluem flexibilidade de infraestrutura, escalabilidade individual, e desenvolvimento paralelo, mas os desafios envolvem complexidade distribuída, consistência de dados, e monitoramento. A aula conecta microserviços ao Kubernetes, reforçando conceitos como **Deployment** e **HPA**, e prepara para discussões futuras sobre comunicação e gerenciamento em sistemas distribuídos.